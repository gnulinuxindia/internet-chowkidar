// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/gnulinuxindia/internet-chowkidar/ent/blocks"
	"github.com/gnulinuxindia/internet-chowkidar/ent/categories"
	"github.com/gnulinuxindia/internet-chowkidar/ent/counter"
	"github.com/gnulinuxindia/internet-chowkidar/ent/isps"
	"github.com/gnulinuxindia/internet-chowkidar/ent/predicate"
	"github.com/gnulinuxindia/internet-chowkidar/ent/sites"
	"github.com/gnulinuxindia/internet-chowkidar/ent/sitescategories"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBlocks          = "Blocks"
	TypeCategories      = "Categories"
	TypeCounter         = "Counter"
	TypeIsps            = "Isps"
	TypeSites           = "Sites"
	TypeSitesCategories = "SitesCategories"
)

// BlocksMutation represents an operation that mutates the Blocks nodes in the graph.
type BlocksMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	client_id        *int
	addclient_id     *int
	blocked          *bool
	last_reported_at *time.Time
	clearedFields    map[string]struct{}
	site             *int
	clearedsite      bool
	isp              *int
	clearedisp       bool
	done             bool
	oldValue         func(context.Context) (*Blocks, error)
	predicates       []predicate.Blocks
}

var _ ent.Mutation = (*BlocksMutation)(nil)

// blocksOption allows management of the mutation configuration using functional options.
type blocksOption func(*BlocksMutation)

// newBlocksMutation creates new mutation for the Blocks entity.
func newBlocksMutation(c config, op Op, opts ...blocksOption) *BlocksMutation {
	m := &BlocksMutation{
		config:        c,
		op:            op,
		typ:           TypeBlocks,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlocksID sets the ID field of the mutation.
func withBlocksID(id int) blocksOption {
	return func(m *BlocksMutation) {
		var (
			err   error
			once  sync.Once
			value *Blocks
		)
		m.oldValue = func(ctx context.Context) (*Blocks, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blocks.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlocks sets the old Blocks of the mutation.
func withBlocks(node *Blocks) blocksOption {
	return func(m *BlocksMutation) {
		m.oldValue = func(context.Context) (*Blocks, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlocksMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlocksMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlocksMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlocksMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blocks.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlocksMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlocksMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Blocks entity.
// If the Blocks object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlocksMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlocksMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlocksMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlocksMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Blocks entity.
// If the Blocks object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlocksMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlocksMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSiteID sets the "site_id" field.
func (m *BlocksMutation) SetSiteID(i int) {
	m.site = &i
}

// SiteID returns the value of the "site_id" field in the mutation.
func (m *BlocksMutation) SiteID() (r int, exists bool) {
	v := m.site
	if v == nil {
		return
	}
	return *v, true
}

// OldSiteID returns the old "site_id" field's value of the Blocks entity.
// If the Blocks object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlocksMutation) OldSiteID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSiteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSiteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiteID: %w", err)
	}
	return oldValue.SiteID, nil
}

// ResetSiteID resets all changes to the "site_id" field.
func (m *BlocksMutation) ResetSiteID() {
	m.site = nil
}

// SetIspID sets the "isp_id" field.
func (m *BlocksMutation) SetIspID(i int) {
	m.isp = &i
}

// IspID returns the value of the "isp_id" field in the mutation.
func (m *BlocksMutation) IspID() (r int, exists bool) {
	v := m.isp
	if v == nil {
		return
	}
	return *v, true
}

// OldIspID returns the old "isp_id" field's value of the Blocks entity.
// If the Blocks object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlocksMutation) OldIspID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIspID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIspID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIspID: %w", err)
	}
	return oldValue.IspID, nil
}

// ResetIspID resets all changes to the "isp_id" field.
func (m *BlocksMutation) ResetIspID() {
	m.isp = nil
}

// SetClientID sets the "client_id" field.
func (m *BlocksMutation) SetClientID(i int) {
	m.client_id = &i
	m.addclient_id = nil
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *BlocksMutation) ClientID() (r int, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the Blocks entity.
// If the Blocks object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlocksMutation) OldClientID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// AddClientID adds i to the "client_id" field.
func (m *BlocksMutation) AddClientID(i int) {
	if m.addclient_id != nil {
		*m.addclient_id += i
	} else {
		m.addclient_id = &i
	}
}

// AddedClientID returns the value that was added to the "client_id" field in this mutation.
func (m *BlocksMutation) AddedClientID() (r int, exists bool) {
	v := m.addclient_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetClientID resets all changes to the "client_id" field.
func (m *BlocksMutation) ResetClientID() {
	m.client_id = nil
	m.addclient_id = nil
}

// SetBlocked sets the "blocked" field.
func (m *BlocksMutation) SetBlocked(b bool) {
	m.blocked = &b
}

// Blocked returns the value of the "blocked" field in the mutation.
func (m *BlocksMutation) Blocked() (r bool, exists bool) {
	v := m.blocked
	if v == nil {
		return
	}
	return *v, true
}

// OldBlocked returns the old "blocked" field's value of the Blocks entity.
// If the Blocks object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlocksMutation) OldBlocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlocked: %w", err)
	}
	return oldValue.Blocked, nil
}

// ResetBlocked resets all changes to the "blocked" field.
func (m *BlocksMutation) ResetBlocked() {
	m.blocked = nil
}

// SetLastReportedAt sets the "last_reported_at" field.
func (m *BlocksMutation) SetLastReportedAt(t time.Time) {
	m.last_reported_at = &t
}

// LastReportedAt returns the value of the "last_reported_at" field in the mutation.
func (m *BlocksMutation) LastReportedAt() (r time.Time, exists bool) {
	v := m.last_reported_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastReportedAt returns the old "last_reported_at" field's value of the Blocks entity.
// If the Blocks object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlocksMutation) OldLastReportedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastReportedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastReportedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastReportedAt: %w", err)
	}
	return oldValue.LastReportedAt, nil
}

// ResetLastReportedAt resets all changes to the "last_reported_at" field.
func (m *BlocksMutation) ResetLastReportedAt() {
	m.last_reported_at = nil
}

// ClearSite clears the "site" edge to the Sites entity.
func (m *BlocksMutation) ClearSite() {
	m.clearedsite = true
	m.clearedFields[blocks.FieldSiteID] = struct{}{}
}

// SiteCleared reports if the "site" edge to the Sites entity was cleared.
func (m *BlocksMutation) SiteCleared() bool {
	return m.clearedsite
}

// SiteIDs returns the "site" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SiteID instead. It exists only for internal usage by the builders.
func (m *BlocksMutation) SiteIDs() (ids []int) {
	if id := m.site; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSite resets all changes to the "site" edge.
func (m *BlocksMutation) ResetSite() {
	m.site = nil
	m.clearedsite = false
}

// ClearIsp clears the "isp" edge to the Isps entity.
func (m *BlocksMutation) ClearIsp() {
	m.clearedisp = true
	m.clearedFields[blocks.FieldIspID] = struct{}{}
}

// IspCleared reports if the "isp" edge to the Isps entity was cleared.
func (m *BlocksMutation) IspCleared() bool {
	return m.clearedisp
}

// IspIDs returns the "isp" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IspID instead. It exists only for internal usage by the builders.
func (m *BlocksMutation) IspIDs() (ids []int) {
	if id := m.isp; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIsp resets all changes to the "isp" edge.
func (m *BlocksMutation) ResetIsp() {
	m.isp = nil
	m.clearedisp = false
}

// Where appends a list predicates to the BlocksMutation builder.
func (m *BlocksMutation) Where(ps ...predicate.Blocks) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlocksMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlocksMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Blocks, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlocksMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlocksMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Blocks).
func (m *BlocksMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlocksMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, blocks.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blocks.FieldUpdatedAt)
	}
	if m.site != nil {
		fields = append(fields, blocks.FieldSiteID)
	}
	if m.isp != nil {
		fields = append(fields, blocks.FieldIspID)
	}
	if m.client_id != nil {
		fields = append(fields, blocks.FieldClientID)
	}
	if m.blocked != nil {
		fields = append(fields, blocks.FieldBlocked)
	}
	if m.last_reported_at != nil {
		fields = append(fields, blocks.FieldLastReportedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlocksMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blocks.FieldCreatedAt:
		return m.CreatedAt()
	case blocks.FieldUpdatedAt:
		return m.UpdatedAt()
	case blocks.FieldSiteID:
		return m.SiteID()
	case blocks.FieldIspID:
		return m.IspID()
	case blocks.FieldClientID:
		return m.ClientID()
	case blocks.FieldBlocked:
		return m.Blocked()
	case blocks.FieldLastReportedAt:
		return m.LastReportedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlocksMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blocks.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blocks.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blocks.FieldSiteID:
		return m.OldSiteID(ctx)
	case blocks.FieldIspID:
		return m.OldIspID(ctx)
	case blocks.FieldClientID:
		return m.OldClientID(ctx)
	case blocks.FieldBlocked:
		return m.OldBlocked(ctx)
	case blocks.FieldLastReportedAt:
		return m.OldLastReportedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Blocks field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlocksMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blocks.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blocks.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blocks.FieldSiteID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiteID(v)
		return nil
	case blocks.FieldIspID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIspID(v)
		return nil
	case blocks.FieldClientID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case blocks.FieldBlocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlocked(v)
		return nil
	case blocks.FieldLastReportedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastReportedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Blocks field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlocksMutation) AddedFields() []string {
	var fields []string
	if m.addclient_id != nil {
		fields = append(fields, blocks.FieldClientID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlocksMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blocks.FieldClientID:
		return m.AddedClientID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlocksMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blocks.FieldClientID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientID(v)
		return nil
	}
	return fmt.Errorf("unknown Blocks numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlocksMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlocksMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlocksMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Blocks nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlocksMutation) ResetField(name string) error {
	switch name {
	case blocks.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blocks.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blocks.FieldSiteID:
		m.ResetSiteID()
		return nil
	case blocks.FieldIspID:
		m.ResetIspID()
		return nil
	case blocks.FieldClientID:
		m.ResetClientID()
		return nil
	case blocks.FieldBlocked:
		m.ResetBlocked()
		return nil
	case blocks.FieldLastReportedAt:
		m.ResetLastReportedAt()
		return nil
	}
	return fmt.Errorf("unknown Blocks field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlocksMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.site != nil {
		edges = append(edges, blocks.EdgeSite)
	}
	if m.isp != nil {
		edges = append(edges, blocks.EdgeIsp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlocksMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blocks.EdgeSite:
		if id := m.site; id != nil {
			return []ent.Value{*id}
		}
	case blocks.EdgeIsp:
		if id := m.isp; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlocksMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlocksMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlocksMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsite {
		edges = append(edges, blocks.EdgeSite)
	}
	if m.clearedisp {
		edges = append(edges, blocks.EdgeIsp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlocksMutation) EdgeCleared(name string) bool {
	switch name {
	case blocks.EdgeSite:
		return m.clearedsite
	case blocks.EdgeIsp:
		return m.clearedisp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlocksMutation) ClearEdge(name string) error {
	switch name {
	case blocks.EdgeSite:
		m.ClearSite()
		return nil
	case blocks.EdgeIsp:
		m.ClearIsp()
		return nil
	}
	return fmt.Errorf("unknown Blocks unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlocksMutation) ResetEdge(name string) error {
	switch name {
	case blocks.EdgeSite:
		m.ResetSite()
		return nil
	case blocks.EdgeIsp:
		m.ResetIsp()
		return nil
	}
	return fmt.Errorf("unknown Blocks edge %s", name)
}

// CategoriesMutation represents an operation that mutates the Categories nodes in the graph.
type CategoriesMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	name                    *string
	clearedFields           map[string]struct{}
	sites                   map[int]struct{}
	removedsites            map[int]struct{}
	clearedsites            bool
	sites_categories        map[int]struct{}
	removedsites_categories map[int]struct{}
	clearedsites_categories bool
	done                    bool
	oldValue                func(context.Context) (*Categories, error)
	predicates              []predicate.Categories
}

var _ ent.Mutation = (*CategoriesMutation)(nil)

// categoriesOption allows management of the mutation configuration using functional options.
type categoriesOption func(*CategoriesMutation)

// newCategoriesMutation creates new mutation for the Categories entity.
func newCategoriesMutation(c config, op Op, opts ...categoriesOption) *CategoriesMutation {
	m := &CategoriesMutation{
		config:        c,
		op:            op,
		typ:           TypeCategories,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoriesID sets the ID field of the mutation.
func withCategoriesID(id int) categoriesOption {
	return func(m *CategoriesMutation) {
		var (
			err   error
			once  sync.Once
			value *Categories
		)
		m.oldValue = func(ctx context.Context) (*Categories, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Categories.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategories sets the old Categories of the mutation.
func withCategories(node *Categories) categoriesOption {
	return func(m *CategoriesMutation) {
		m.oldValue = func(context.Context) (*Categories, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoriesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoriesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoriesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoriesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Categories.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoriesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoriesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Categories entity.
// If the Categories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoriesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoriesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoriesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoriesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Categories entity.
// If the Categories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoriesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoriesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CategoriesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoriesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Categories entity.
// If the Categories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoriesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoriesMutation) ResetName() {
	m.name = nil
}

// AddSiteIDs adds the "sites" edge to the Sites entity by ids.
func (m *CategoriesMutation) AddSiteIDs(ids ...int) {
	if m.sites == nil {
		m.sites = make(map[int]struct{})
	}
	for i := range ids {
		m.sites[ids[i]] = struct{}{}
	}
}

// ClearSites clears the "sites" edge to the Sites entity.
func (m *CategoriesMutation) ClearSites() {
	m.clearedsites = true
}

// SitesCleared reports if the "sites" edge to the Sites entity was cleared.
func (m *CategoriesMutation) SitesCleared() bool {
	return m.clearedsites
}

// RemoveSiteIDs removes the "sites" edge to the Sites entity by IDs.
func (m *CategoriesMutation) RemoveSiteIDs(ids ...int) {
	if m.removedsites == nil {
		m.removedsites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sites, ids[i])
		m.removedsites[ids[i]] = struct{}{}
	}
}

// RemovedSites returns the removed IDs of the "sites" edge to the Sites entity.
func (m *CategoriesMutation) RemovedSitesIDs() (ids []int) {
	for id := range m.removedsites {
		ids = append(ids, id)
	}
	return
}

// SitesIDs returns the "sites" edge IDs in the mutation.
func (m *CategoriesMutation) SitesIDs() (ids []int) {
	for id := range m.sites {
		ids = append(ids, id)
	}
	return
}

// ResetSites resets all changes to the "sites" edge.
func (m *CategoriesMutation) ResetSites() {
	m.sites = nil
	m.clearedsites = false
	m.removedsites = nil
}

// AddSitesCategoryIDs adds the "sites_categories" edge to the SitesCategories entity by ids.
func (m *CategoriesMutation) AddSitesCategoryIDs(ids ...int) {
	if m.sites_categories == nil {
		m.sites_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.sites_categories[ids[i]] = struct{}{}
	}
}

// ClearSitesCategories clears the "sites_categories" edge to the SitesCategories entity.
func (m *CategoriesMutation) ClearSitesCategories() {
	m.clearedsites_categories = true
}

// SitesCategoriesCleared reports if the "sites_categories" edge to the SitesCategories entity was cleared.
func (m *CategoriesMutation) SitesCategoriesCleared() bool {
	return m.clearedsites_categories
}

// RemoveSitesCategoryIDs removes the "sites_categories" edge to the SitesCategories entity by IDs.
func (m *CategoriesMutation) RemoveSitesCategoryIDs(ids ...int) {
	if m.removedsites_categories == nil {
		m.removedsites_categories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sites_categories, ids[i])
		m.removedsites_categories[ids[i]] = struct{}{}
	}
}

// RemovedSitesCategories returns the removed IDs of the "sites_categories" edge to the SitesCategories entity.
func (m *CategoriesMutation) RemovedSitesCategoriesIDs() (ids []int) {
	for id := range m.removedsites_categories {
		ids = append(ids, id)
	}
	return
}

// SitesCategoriesIDs returns the "sites_categories" edge IDs in the mutation.
func (m *CategoriesMutation) SitesCategoriesIDs() (ids []int) {
	for id := range m.sites_categories {
		ids = append(ids, id)
	}
	return
}

// ResetSitesCategories resets all changes to the "sites_categories" edge.
func (m *CategoriesMutation) ResetSitesCategories() {
	m.sites_categories = nil
	m.clearedsites_categories = false
	m.removedsites_categories = nil
}

// Where appends a list predicates to the CategoriesMutation builder.
func (m *CategoriesMutation) Where(ps ...predicate.Categories) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoriesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoriesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Categories, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoriesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoriesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Categories).
func (m *CategoriesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoriesMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, categories.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, categories.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, categories.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoriesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case categories.FieldCreatedAt:
		return m.CreatedAt()
	case categories.FieldUpdatedAt:
		return m.UpdatedAt()
	case categories.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoriesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case categories.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case categories.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case categories.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Categories field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoriesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case categories.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case categories.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case categories.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Categories field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoriesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoriesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoriesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Categories numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoriesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoriesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoriesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Categories nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoriesMutation) ResetField(name string) error {
	switch name {
	case categories.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case categories.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case categories.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Categories field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoriesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.sites != nil {
		edges = append(edges, categories.EdgeSites)
	}
	if m.sites_categories != nil {
		edges = append(edges, categories.EdgeSitesCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoriesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case categories.EdgeSites:
		ids := make([]ent.Value, 0, len(m.sites))
		for id := range m.sites {
			ids = append(ids, id)
		}
		return ids
	case categories.EdgeSitesCategories:
		ids := make([]ent.Value, 0, len(m.sites_categories))
		for id := range m.sites_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoriesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsites != nil {
		edges = append(edges, categories.EdgeSites)
	}
	if m.removedsites_categories != nil {
		edges = append(edges, categories.EdgeSitesCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoriesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case categories.EdgeSites:
		ids := make([]ent.Value, 0, len(m.removedsites))
		for id := range m.removedsites {
			ids = append(ids, id)
		}
		return ids
	case categories.EdgeSitesCategories:
		ids := make([]ent.Value, 0, len(m.removedsites_categories))
		for id := range m.removedsites_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoriesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsites {
		edges = append(edges, categories.EdgeSites)
	}
	if m.clearedsites_categories {
		edges = append(edges, categories.EdgeSitesCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoriesMutation) EdgeCleared(name string) bool {
	switch name {
	case categories.EdgeSites:
		return m.clearedsites
	case categories.EdgeSitesCategories:
		return m.clearedsites_categories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoriesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Categories unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoriesMutation) ResetEdge(name string) error {
	switch name {
	case categories.EdgeSites:
		m.ResetSites()
		return nil
	case categories.EdgeSitesCategories:
		m.ResetSitesCategories()
		return nil
	}
	return fmt.Errorf("unknown Categories edge %s", name)
}

// CounterMutation represents an operation that mutates the Counter nodes in the graph.
type CounterMutation struct {
	config
	op            Op
	typ           string
	id            *int
	count         *int
	addcount      *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Counter, error)
	predicates    []predicate.Counter
}

var _ ent.Mutation = (*CounterMutation)(nil)

// counterOption allows management of the mutation configuration using functional options.
type counterOption func(*CounterMutation)

// newCounterMutation creates new mutation for the Counter entity.
func newCounterMutation(c config, op Op, opts ...counterOption) *CounterMutation {
	m := &CounterMutation{
		config:        c,
		op:            op,
		typ:           TypeCounter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCounterID sets the ID field of the mutation.
func withCounterID(id int) counterOption {
	return func(m *CounterMutation) {
		var (
			err   error
			once  sync.Once
			value *Counter
		)
		m.oldValue = func(ctx context.Context) (*Counter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Counter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCounter sets the old Counter of the mutation.
func withCounter(node *Counter) counterOption {
	return func(m *CounterMutation) {
		m.oldValue = func(context.Context) (*Counter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CounterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CounterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CounterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CounterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Counter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCount sets the "count" field.
func (m *CounterMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *CounterMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the Counter entity.
// If the Counter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CounterMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *CounterMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *CounterMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *CounterMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// Where appends a list predicates to the CounterMutation builder.
func (m *CounterMutation) Where(ps ...predicate.Counter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CounterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CounterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Counter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CounterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CounterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Counter).
func (m *CounterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CounterMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.count != nil {
		fields = append(fields, counter.FieldCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CounterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case counter.FieldCount:
		return m.Count()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CounterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case counter.FieldCount:
		return m.OldCount(ctx)
	}
	return nil, fmt.Errorf("unknown Counter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CounterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case counter.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	}
	return fmt.Errorf("unknown Counter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CounterMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, counter.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CounterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case counter.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CounterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case counter.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown Counter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CounterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CounterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CounterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Counter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CounterMutation) ResetField(name string) error {
	switch name {
	case counter.FieldCount:
		m.ResetCount()
		return nil
	}
	return fmt.Errorf("unknown Counter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CounterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CounterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CounterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CounterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CounterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CounterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CounterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Counter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CounterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Counter edge %s", name)
}

// IspsMutation represents an operation that mutates the Isps nodes in the graph.
type IspsMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	latitude          *float64
	addlatitude       *float64
	longitude         *float64
	addlongitude      *float64
	name              *string
	clearedFields     map[string]struct{}
	isp_blocks        map[int]struct{}
	removedisp_blocks map[int]struct{}
	clearedisp_blocks bool
	done              bool
	oldValue          func(context.Context) (*Isps, error)
	predicates        []predicate.Isps
}

var _ ent.Mutation = (*IspsMutation)(nil)

// ispsOption allows management of the mutation configuration using functional options.
type ispsOption func(*IspsMutation)

// newIspsMutation creates new mutation for the Isps entity.
func newIspsMutation(c config, op Op, opts ...ispsOption) *IspsMutation {
	m := &IspsMutation{
		config:        c,
		op:            op,
		typ:           TypeIsps,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIspsID sets the ID field of the mutation.
func withIspsID(id int) ispsOption {
	return func(m *IspsMutation) {
		var (
			err   error
			once  sync.Once
			value *Isps
		)
		m.oldValue = func(ctx context.Context) (*Isps, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Isps.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIsps sets the old Isps of the mutation.
func withIsps(node *Isps) ispsOption {
	return func(m *IspsMutation) {
		m.oldValue = func(context.Context) (*Isps, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IspsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IspsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IspsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IspsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Isps.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IspsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IspsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Isps entity.
// If the Isps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IspsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IspsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IspsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IspsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Isps entity.
// If the Isps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IspsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IspsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLatitude sets the "latitude" field.
func (m *IspsMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *IspsMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Isps entity.
// If the Isps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IspsMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *IspsMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *IspsMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *IspsMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetLongitude sets the "longitude" field.
func (m *IspsMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *IspsMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Isps entity.
// If the Isps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IspsMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *IspsMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *IspsMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *IspsMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetName sets the "name" field.
func (m *IspsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IspsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Isps entity.
// If the Isps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IspsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IspsMutation) ResetName() {
	m.name = nil
}

// AddIspBlockIDs adds the "isp_blocks" edge to the Blocks entity by ids.
func (m *IspsMutation) AddIspBlockIDs(ids ...int) {
	if m.isp_blocks == nil {
		m.isp_blocks = make(map[int]struct{})
	}
	for i := range ids {
		m.isp_blocks[ids[i]] = struct{}{}
	}
}

// ClearIspBlocks clears the "isp_blocks" edge to the Blocks entity.
func (m *IspsMutation) ClearIspBlocks() {
	m.clearedisp_blocks = true
}

// IspBlocksCleared reports if the "isp_blocks" edge to the Blocks entity was cleared.
func (m *IspsMutation) IspBlocksCleared() bool {
	return m.clearedisp_blocks
}

// RemoveIspBlockIDs removes the "isp_blocks" edge to the Blocks entity by IDs.
func (m *IspsMutation) RemoveIspBlockIDs(ids ...int) {
	if m.removedisp_blocks == nil {
		m.removedisp_blocks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.isp_blocks, ids[i])
		m.removedisp_blocks[ids[i]] = struct{}{}
	}
}

// RemovedIspBlocks returns the removed IDs of the "isp_blocks" edge to the Blocks entity.
func (m *IspsMutation) RemovedIspBlocksIDs() (ids []int) {
	for id := range m.removedisp_blocks {
		ids = append(ids, id)
	}
	return
}

// IspBlocksIDs returns the "isp_blocks" edge IDs in the mutation.
func (m *IspsMutation) IspBlocksIDs() (ids []int) {
	for id := range m.isp_blocks {
		ids = append(ids, id)
	}
	return
}

// ResetIspBlocks resets all changes to the "isp_blocks" edge.
func (m *IspsMutation) ResetIspBlocks() {
	m.isp_blocks = nil
	m.clearedisp_blocks = false
	m.removedisp_blocks = nil
}

// Where appends a list predicates to the IspsMutation builder.
func (m *IspsMutation) Where(ps ...predicate.Isps) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IspsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IspsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Isps, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IspsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IspsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Isps).
func (m *IspsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IspsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, isps.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, isps.FieldUpdatedAt)
	}
	if m.latitude != nil {
		fields = append(fields, isps.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, isps.FieldLongitude)
	}
	if m.name != nil {
		fields = append(fields, isps.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IspsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case isps.FieldCreatedAt:
		return m.CreatedAt()
	case isps.FieldUpdatedAt:
		return m.UpdatedAt()
	case isps.FieldLatitude:
		return m.Latitude()
	case isps.FieldLongitude:
		return m.Longitude()
	case isps.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IspsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case isps.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case isps.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case isps.FieldLatitude:
		return m.OldLatitude(ctx)
	case isps.FieldLongitude:
		return m.OldLongitude(ctx)
	case isps.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Isps field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IspsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case isps.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case isps.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case isps.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case isps.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case isps.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Isps field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IspsMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, isps.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, isps.FieldLongitude)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IspsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case isps.FieldLatitude:
		return m.AddedLatitude()
	case isps.FieldLongitude:
		return m.AddedLongitude()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IspsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case isps.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case isps.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown Isps numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IspsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IspsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IspsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Isps nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IspsMutation) ResetField(name string) error {
	switch name {
	case isps.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case isps.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case isps.FieldLatitude:
		m.ResetLatitude()
		return nil
	case isps.FieldLongitude:
		m.ResetLongitude()
		return nil
	case isps.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Isps field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IspsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.isp_blocks != nil {
		edges = append(edges, isps.EdgeIspBlocks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IspsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case isps.EdgeIspBlocks:
		ids := make([]ent.Value, 0, len(m.isp_blocks))
		for id := range m.isp_blocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IspsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedisp_blocks != nil {
		edges = append(edges, isps.EdgeIspBlocks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IspsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case isps.EdgeIspBlocks:
		ids := make([]ent.Value, 0, len(m.removedisp_blocks))
		for id := range m.removedisp_blocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IspsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedisp_blocks {
		edges = append(edges, isps.EdgeIspBlocks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IspsMutation) EdgeCleared(name string) bool {
	switch name {
	case isps.EdgeIspBlocks:
		return m.clearedisp_blocks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IspsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Isps unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IspsMutation) ResetEdge(name string) error {
	switch name {
	case isps.EdgeIspBlocks:
		m.ResetIspBlocks()
		return nil
	}
	return fmt.Errorf("unknown Isps edge %s", name)
}

// SitesMutation represents an operation that mutates the Sites nodes in the graph.
type SitesMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	domain                  *string
	ping_url                *string
	clearedFields           map[string]struct{}
	blocks                  map[int]struct{}
	removedblocks           map[int]struct{}
	clearedblocks           bool
	categories              map[int]struct{}
	removedcategories       map[int]struct{}
	clearedcategories       bool
	sites_categories        map[int]struct{}
	removedsites_categories map[int]struct{}
	clearedsites_categories bool
	done                    bool
	oldValue                func(context.Context) (*Sites, error)
	predicates              []predicate.Sites
}

var _ ent.Mutation = (*SitesMutation)(nil)

// sitesOption allows management of the mutation configuration using functional options.
type sitesOption func(*SitesMutation)

// newSitesMutation creates new mutation for the Sites entity.
func newSitesMutation(c config, op Op, opts ...sitesOption) *SitesMutation {
	m := &SitesMutation{
		config:        c,
		op:            op,
		typ:           TypeSites,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSitesID sets the ID field of the mutation.
func withSitesID(id int) sitesOption {
	return func(m *SitesMutation) {
		var (
			err   error
			once  sync.Once
			value *Sites
		)
		m.oldValue = func(ctx context.Context) (*Sites, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sites.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSites sets the old Sites of the mutation.
func withSites(node *Sites) sitesOption {
	return func(m *SitesMutation) {
		m.oldValue = func(context.Context) (*Sites, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SitesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SitesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SitesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SitesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Sites.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SitesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SitesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Sites entity.
// If the Sites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SitesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SitesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SitesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SitesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Sites entity.
// If the Sites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SitesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SitesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDomain sets the "domain" field.
func (m *SitesMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *SitesMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Sites entity.
// If the Sites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SitesMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *SitesMutation) ResetDomain() {
	m.domain = nil
}

// SetPingURL sets the "ping_url" field.
func (m *SitesMutation) SetPingURL(s string) {
	m.ping_url = &s
}

// PingURL returns the value of the "ping_url" field in the mutation.
func (m *SitesMutation) PingURL() (r string, exists bool) {
	v := m.ping_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPingURL returns the old "ping_url" field's value of the Sites entity.
// If the Sites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SitesMutation) OldPingURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPingURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPingURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPingURL: %w", err)
	}
	return oldValue.PingURL, nil
}

// ResetPingURL resets all changes to the "ping_url" field.
func (m *SitesMutation) ResetPingURL() {
	m.ping_url = nil
}

// AddBlockIDs adds the "blocks" edge to the Blocks entity by ids.
func (m *SitesMutation) AddBlockIDs(ids ...int) {
	if m.blocks == nil {
		m.blocks = make(map[int]struct{})
	}
	for i := range ids {
		m.blocks[ids[i]] = struct{}{}
	}
}

// ClearBlocks clears the "blocks" edge to the Blocks entity.
func (m *SitesMutation) ClearBlocks() {
	m.clearedblocks = true
}

// BlocksCleared reports if the "blocks" edge to the Blocks entity was cleared.
func (m *SitesMutation) BlocksCleared() bool {
	return m.clearedblocks
}

// RemoveBlockIDs removes the "blocks" edge to the Blocks entity by IDs.
func (m *SitesMutation) RemoveBlockIDs(ids ...int) {
	if m.removedblocks == nil {
		m.removedblocks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.blocks, ids[i])
		m.removedblocks[ids[i]] = struct{}{}
	}
}

// RemovedBlocks returns the removed IDs of the "blocks" edge to the Blocks entity.
func (m *SitesMutation) RemovedBlocksIDs() (ids []int) {
	for id := range m.removedblocks {
		ids = append(ids, id)
	}
	return
}

// BlocksIDs returns the "blocks" edge IDs in the mutation.
func (m *SitesMutation) BlocksIDs() (ids []int) {
	for id := range m.blocks {
		ids = append(ids, id)
	}
	return
}

// ResetBlocks resets all changes to the "blocks" edge.
func (m *SitesMutation) ResetBlocks() {
	m.blocks = nil
	m.clearedblocks = false
	m.removedblocks = nil
}

// AddCategoryIDs adds the "categories" edge to the Categories entity by ids.
func (m *SitesMutation) AddCategoryIDs(ids ...int) {
	if m.categories == nil {
		m.categories = make(map[int]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Categories entity.
func (m *SitesMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Categories entity was cleared.
func (m *SitesMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Categories entity by IDs.
func (m *SitesMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Categories entity.
func (m *SitesMutation) RemovedCategoriesIDs() (ids []int) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *SitesMutation) CategoriesIDs() (ids []int) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *SitesMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddSitesCategoryIDs adds the "sites_categories" edge to the SitesCategories entity by ids.
func (m *SitesMutation) AddSitesCategoryIDs(ids ...int) {
	if m.sites_categories == nil {
		m.sites_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.sites_categories[ids[i]] = struct{}{}
	}
}

// ClearSitesCategories clears the "sites_categories" edge to the SitesCategories entity.
func (m *SitesMutation) ClearSitesCategories() {
	m.clearedsites_categories = true
}

// SitesCategoriesCleared reports if the "sites_categories" edge to the SitesCategories entity was cleared.
func (m *SitesMutation) SitesCategoriesCleared() bool {
	return m.clearedsites_categories
}

// RemoveSitesCategoryIDs removes the "sites_categories" edge to the SitesCategories entity by IDs.
func (m *SitesMutation) RemoveSitesCategoryIDs(ids ...int) {
	if m.removedsites_categories == nil {
		m.removedsites_categories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sites_categories, ids[i])
		m.removedsites_categories[ids[i]] = struct{}{}
	}
}

// RemovedSitesCategories returns the removed IDs of the "sites_categories" edge to the SitesCategories entity.
func (m *SitesMutation) RemovedSitesCategoriesIDs() (ids []int) {
	for id := range m.removedsites_categories {
		ids = append(ids, id)
	}
	return
}

// SitesCategoriesIDs returns the "sites_categories" edge IDs in the mutation.
func (m *SitesMutation) SitesCategoriesIDs() (ids []int) {
	for id := range m.sites_categories {
		ids = append(ids, id)
	}
	return
}

// ResetSitesCategories resets all changes to the "sites_categories" edge.
func (m *SitesMutation) ResetSitesCategories() {
	m.sites_categories = nil
	m.clearedsites_categories = false
	m.removedsites_categories = nil
}

// Where appends a list predicates to the SitesMutation builder.
func (m *SitesMutation) Where(ps ...predicate.Sites) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SitesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SitesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Sites, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SitesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SitesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Sites).
func (m *SitesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SitesMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, sites.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sites.FieldUpdatedAt)
	}
	if m.domain != nil {
		fields = append(fields, sites.FieldDomain)
	}
	if m.ping_url != nil {
		fields = append(fields, sites.FieldPingURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SitesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sites.FieldCreatedAt:
		return m.CreatedAt()
	case sites.FieldUpdatedAt:
		return m.UpdatedAt()
	case sites.FieldDomain:
		return m.Domain()
	case sites.FieldPingURL:
		return m.PingURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SitesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sites.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sites.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sites.FieldDomain:
		return m.OldDomain(ctx)
	case sites.FieldPingURL:
		return m.OldPingURL(ctx)
	}
	return nil, fmt.Errorf("unknown Sites field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SitesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sites.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sites.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sites.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case sites.FieldPingURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPingURL(v)
		return nil
	}
	return fmt.Errorf("unknown Sites field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SitesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SitesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SitesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Sites numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SitesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SitesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SitesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Sites nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SitesMutation) ResetField(name string) error {
	switch name {
	case sites.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sites.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sites.FieldDomain:
		m.ResetDomain()
		return nil
	case sites.FieldPingURL:
		m.ResetPingURL()
		return nil
	}
	return fmt.Errorf("unknown Sites field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SitesMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.blocks != nil {
		edges = append(edges, sites.EdgeBlocks)
	}
	if m.categories != nil {
		edges = append(edges, sites.EdgeCategories)
	}
	if m.sites_categories != nil {
		edges = append(edges, sites.EdgeSitesCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SitesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sites.EdgeBlocks:
		ids := make([]ent.Value, 0, len(m.blocks))
		for id := range m.blocks {
			ids = append(ids, id)
		}
		return ids
	case sites.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case sites.EdgeSitesCategories:
		ids := make([]ent.Value, 0, len(m.sites_categories))
		for id := range m.sites_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SitesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedblocks != nil {
		edges = append(edges, sites.EdgeBlocks)
	}
	if m.removedcategories != nil {
		edges = append(edges, sites.EdgeCategories)
	}
	if m.removedsites_categories != nil {
		edges = append(edges, sites.EdgeSitesCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SitesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sites.EdgeBlocks:
		ids := make([]ent.Value, 0, len(m.removedblocks))
		for id := range m.removedblocks {
			ids = append(ids, id)
		}
		return ids
	case sites.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case sites.EdgeSitesCategories:
		ids := make([]ent.Value, 0, len(m.removedsites_categories))
		for id := range m.removedsites_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SitesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedblocks {
		edges = append(edges, sites.EdgeBlocks)
	}
	if m.clearedcategories {
		edges = append(edges, sites.EdgeCategories)
	}
	if m.clearedsites_categories {
		edges = append(edges, sites.EdgeSitesCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SitesMutation) EdgeCleared(name string) bool {
	switch name {
	case sites.EdgeBlocks:
		return m.clearedblocks
	case sites.EdgeCategories:
		return m.clearedcategories
	case sites.EdgeSitesCategories:
		return m.clearedsites_categories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SitesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Sites unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SitesMutation) ResetEdge(name string) error {
	switch name {
	case sites.EdgeBlocks:
		m.ResetBlocks()
		return nil
	case sites.EdgeCategories:
		m.ResetCategories()
		return nil
	case sites.EdgeSitesCategories:
		m.ResetSitesCategories()
		return nil
	}
	return fmt.Errorf("unknown Sites edge %s", name)
}

// SitesCategoriesMutation represents an operation that mutates the SitesCategories nodes in the graph.
type SitesCategoriesMutation struct {
	config
	op                Op
	typ               string
	id                *int
	clearedFields     map[string]struct{}
	sites             *int
	clearedsites      bool
	categories        *int
	clearedcategories bool
	done              bool
	oldValue          func(context.Context) (*SitesCategories, error)
	predicates        []predicate.SitesCategories
}

var _ ent.Mutation = (*SitesCategoriesMutation)(nil)

// sitescategoriesOption allows management of the mutation configuration using functional options.
type sitescategoriesOption func(*SitesCategoriesMutation)

// newSitesCategoriesMutation creates new mutation for the SitesCategories entity.
func newSitesCategoriesMutation(c config, op Op, opts ...sitescategoriesOption) *SitesCategoriesMutation {
	m := &SitesCategoriesMutation{
		config:        c,
		op:            op,
		typ:           TypeSitesCategories,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSitesCategoriesID sets the ID field of the mutation.
func withSitesCategoriesID(id int) sitescategoriesOption {
	return func(m *SitesCategoriesMutation) {
		var (
			err   error
			once  sync.Once
			value *SitesCategories
		)
		m.oldValue = func(ctx context.Context) (*SitesCategories, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SitesCategories.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSitesCategories sets the old SitesCategories of the mutation.
func withSitesCategories(node *SitesCategories) sitescategoriesOption {
	return func(m *SitesCategoriesMutation) {
		m.oldValue = func(context.Context) (*SitesCategories, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SitesCategoriesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SitesCategoriesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SitesCategoriesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SitesCategoriesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SitesCategories.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSitesID sets the "sites_id" field.
func (m *SitesCategoriesMutation) SetSitesID(i int) {
	m.sites = &i
}

// SitesID returns the value of the "sites_id" field in the mutation.
func (m *SitesCategoriesMutation) SitesID() (r int, exists bool) {
	v := m.sites
	if v == nil {
		return
	}
	return *v, true
}

// OldSitesID returns the old "sites_id" field's value of the SitesCategories entity.
// If the SitesCategories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SitesCategoriesMutation) OldSitesID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSitesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSitesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSitesID: %w", err)
	}
	return oldValue.SitesID, nil
}

// ResetSitesID resets all changes to the "sites_id" field.
func (m *SitesCategoriesMutation) ResetSitesID() {
	m.sites = nil
}

// SetCategoriesID sets the "categories_id" field.
func (m *SitesCategoriesMutation) SetCategoriesID(i int) {
	m.categories = &i
}

// CategoriesID returns the value of the "categories_id" field in the mutation.
func (m *SitesCategoriesMutation) CategoriesID() (r int, exists bool) {
	v := m.categories
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoriesID returns the old "categories_id" field's value of the SitesCategories entity.
// If the SitesCategories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SitesCategoriesMutation) OldCategoriesID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoriesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoriesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoriesID: %w", err)
	}
	return oldValue.CategoriesID, nil
}

// ResetCategoriesID resets all changes to the "categories_id" field.
func (m *SitesCategoriesMutation) ResetCategoriesID() {
	m.categories = nil
}

// ClearSites clears the "sites" edge to the Sites entity.
func (m *SitesCategoriesMutation) ClearSites() {
	m.clearedsites = true
	m.clearedFields[sitescategories.FieldSitesID] = struct{}{}
}

// SitesCleared reports if the "sites" edge to the Sites entity was cleared.
func (m *SitesCategoriesMutation) SitesCleared() bool {
	return m.clearedsites
}

// SitesIDs returns the "sites" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SitesID instead. It exists only for internal usage by the builders.
func (m *SitesCategoriesMutation) SitesIDs() (ids []int) {
	if id := m.sites; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSites resets all changes to the "sites" edge.
func (m *SitesCategoriesMutation) ResetSites() {
	m.sites = nil
	m.clearedsites = false
}

// ClearCategories clears the "categories" edge to the Categories entity.
func (m *SitesCategoriesMutation) ClearCategories() {
	m.clearedcategories = true
	m.clearedFields[sitescategories.FieldCategoriesID] = struct{}{}
}

// CategoriesCleared reports if the "categories" edge to the Categories entity was cleared.
func (m *SitesCategoriesMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoriesID instead. It exists only for internal usage by the builders.
func (m *SitesCategoriesMutation) CategoriesIDs() (ids []int) {
	if id := m.categories; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *SitesCategoriesMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
}

// Where appends a list predicates to the SitesCategoriesMutation builder.
func (m *SitesCategoriesMutation) Where(ps ...predicate.SitesCategories) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SitesCategoriesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SitesCategoriesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SitesCategories, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SitesCategoriesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SitesCategoriesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SitesCategories).
func (m *SitesCategoriesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SitesCategoriesMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.sites != nil {
		fields = append(fields, sitescategories.FieldSitesID)
	}
	if m.categories != nil {
		fields = append(fields, sitescategories.FieldCategoriesID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SitesCategoriesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sitescategories.FieldSitesID:
		return m.SitesID()
	case sitescategories.FieldCategoriesID:
		return m.CategoriesID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SitesCategoriesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sitescategories.FieldSitesID:
		return m.OldSitesID(ctx)
	case sitescategories.FieldCategoriesID:
		return m.OldCategoriesID(ctx)
	}
	return nil, fmt.Errorf("unknown SitesCategories field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SitesCategoriesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sitescategories.FieldSitesID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSitesID(v)
		return nil
	case sitescategories.FieldCategoriesID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoriesID(v)
		return nil
	}
	return fmt.Errorf("unknown SitesCategories field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SitesCategoriesMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SitesCategoriesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SitesCategoriesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SitesCategories numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SitesCategoriesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SitesCategoriesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SitesCategoriesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SitesCategories nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SitesCategoriesMutation) ResetField(name string) error {
	switch name {
	case sitescategories.FieldSitesID:
		m.ResetSitesID()
		return nil
	case sitescategories.FieldCategoriesID:
		m.ResetCategoriesID()
		return nil
	}
	return fmt.Errorf("unknown SitesCategories field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SitesCategoriesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.sites != nil {
		edges = append(edges, sitescategories.EdgeSites)
	}
	if m.categories != nil {
		edges = append(edges, sitescategories.EdgeCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SitesCategoriesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sitescategories.EdgeSites:
		if id := m.sites; id != nil {
			return []ent.Value{*id}
		}
	case sitescategories.EdgeCategories:
		if id := m.categories; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SitesCategoriesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SitesCategoriesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SitesCategoriesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsites {
		edges = append(edges, sitescategories.EdgeSites)
	}
	if m.clearedcategories {
		edges = append(edges, sitescategories.EdgeCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SitesCategoriesMutation) EdgeCleared(name string) bool {
	switch name {
	case sitescategories.EdgeSites:
		return m.clearedsites
	case sitescategories.EdgeCategories:
		return m.clearedcategories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SitesCategoriesMutation) ClearEdge(name string) error {
	switch name {
	case sitescategories.EdgeSites:
		m.ClearSites()
		return nil
	case sitescategories.EdgeCategories:
		m.ClearCategories()
		return nil
	}
	return fmt.Errorf("unknown SitesCategories unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SitesCategoriesMutation) ResetEdge(name string) error {
	switch name {
	case sitescategories.EdgeSites:
		m.ResetSites()
		return nil
	case sitescategories.EdgeCategories:
		m.ResetCategories()
		return nil
	}
	return fmt.Errorf("unknown SitesCategories edge %s", name)
}
